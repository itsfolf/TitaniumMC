From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Mon, 4 Jan 2021 21:06:13 -0500
Subject: [PATCH] Dimentional Threading


diff --git a/src/main/java/me/titaniumtown/DimThread/DimThread.java b/src/main/java/me/titaniumtown/DimThread/DimThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b1e1ca4e8202e44edd00d4b6ff7005d7eb3f282
--- /dev/null
+++ b/src/main/java/me/titaniumtown/DimThread/DimThread.java
@@ -0,0 +1,53 @@
+package me.titaniumtown.dimthread;
+
+import me.titaniumtown.dimthread.thread.IMutableMainThread;
+import me.titaniumtown.dimthread.util.ServerManager;
+import me.titaniumtown.threading.ThreadPool;
+import net.minecraft.server.WorldServer;
+import net.minecraft.server.MinecraftServer;
+
+public class DimThread {
+    public static final String MOD_ID = "dimthread";
+    public static final ServerManager MANAGER = new ServerManager();
+
+    public static ThreadPool getThreadPool(MinecraftServer server) {
+        return MANAGER.getThreadPool(server);
+    }
+
+    public static void swapThreadsAndRun(Runnable task, Object... threadedObjects) {
+        Thread currentThread = Thread.currentThread();
+        Thread[] oldThreads = new Thread[threadedObjects.length];
+
+        for(int i = 0; i < oldThreads.length; i++) {
+            oldThreads[i] = ((IMutableMainThread)threadedObjects[i]).getMainThread();
+            ((IMutableMainThread)threadedObjects[i]).setMainThread(currentThread);
+        }
+
+        task.run();
+
+        for(int i = 0; i < oldThreads.length; i++) {
+            ((IMutableMainThread)threadedObjects[i]).setMainThread(oldThreads[i]);
+        }
+    }
+
+    /**
+        * Makes it easy to understand what is happening in crash reports and helps identify dimthread workers.
+        * */
+    public static void attach(Thread thread, String name) {
+        thread.setName(MOD_ID + "_" + name);
+    }
+
+    public static void attach(Thread thread, WorldServer world) {
+        // attach(thread, world.getRegistryKey().getValue().getPath());
+        thread.setName(MOD_ID);
+    }
+
+    /**
+        * Checks if the given thread is a dimthread worker by checking the name. Probably quite fragile...
+        * */
+    // `Thread.currentThread() == this.serverThread` is the same as `me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())`
+    // `Thread.currentThread() != this.serverThread` is the same as `!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())`
+    public static boolean owns(Thread thread) {
+        return thread.getName().startsWith(MOD_ID);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/DimThread/thread/IMutableMainThread.java b/src/main/java/me/titaniumtown/DimThread/thread/IMutableMainThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..475597240a1c091e6a1ff6be0682ff996ea91da1
--- /dev/null
+++ b/src/main/java/me/titaniumtown/DimThread/thread/IMutableMainThread.java
@@ -0,0 +1,6 @@
+package me.titaniumtown.dimthread.thread;
+
+public interface IMutableMainThread {
+	Thread getMainThread();
+	void setMainThread(Thread thread);
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/DimThread/util/ServerManager.java b/src/main/java/me/titaniumtown/DimThread/util/ServerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..7871ea9f536b4ab907ff64493905aa7467706f6f
--- /dev/null
+++ b/src/main/java/me/titaniumtown/DimThread/util/ServerManager.java
@@ -0,0 +1,39 @@
+package me.titaniumtown.dimthread.util;
+
+import net.minecraft.server.MinecraftServer;
+import me.titaniumtown.threading.ThreadPool;
+
+import java.util.Collections;
+import java.util.ConcurrentModificationException;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+public class ServerManager {
+
+	private final Map<MinecraftServer, Boolean> actives = Collections.synchronizedMap(new WeakHashMap<>());
+	private final Map<MinecraftServer, ThreadPool> threadPools = Collections.synchronizedMap(new WeakHashMap<>());
+
+	public boolean isActive(MinecraftServer server) {
+		return me.titaniumtown.TitaniumConfig.dimThreading;
+	}
+
+	public void setActive(MinecraftServer server) {
+		this.actives.put(server, me.titaniumtown.TitaniumConfig.dimThreading);
+	}
+
+	public ThreadPool getThreadPool(MinecraftServer server) {
+		return this.threadPools.computeIfAbsent(server, s -> new ThreadPool(me.titaniumtown.TitaniumConfig.dimThreadingThreads));
+	}
+
+	public void setThreadCount(MinecraftServer server) {
+		ThreadPool current = this.threadPools.get(server);
+
+		// if(current.getActiveCount() != 0) {
+		// 	throw new ConcurrentModificationException("Setting the thread count in wrong phase");
+		// }
+
+		this.threadPools.put(server, new ThreadPool(me.titaniumtown.TitaniumConfig.dimThreadingThreads));
+		current.shutdown();
+	}
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/TitaniumConfig.java b/src/main/java/me/titaniumtown/TitaniumConfig.java
index 4737daae4b0acd65dbbc5e56134885c50ce36e64..e42dccedd0961ae9672f615e4e07f43b9925c9f7 100644
--- a/src/main/java/me/titaniumtown/TitaniumConfig.java
+++ b/src/main/java/me/titaniumtown/TitaniumConfig.java
@@ -156,10 +156,14 @@ public class TitaniumConfig {
     public static boolean allowSandDupe = false;
     public static boolean worldBorderChecks = true;
     public static boolean allowAllDupes = false;
+    public static int dimThreadingThreads = 4;
+    public static boolean dimThreading = false;
     private static void experimental() {
         allowSandDupe = getBoolean("settings.experimental.allow-sand-dupe", allowSandDupe);
         worldBorderChecks = getBoolean("settings.experimental.world-border-checks", worldBorderChecks);
         allowAllDupes = getBoolean("settings.experimental.allow-all-dupes", allowAllDupes);
+        dimThreadingThreads = getInt("settings.experimental.dimentional-threads", dimThreadingThreads);
+        dimThreading = getBoolean("settings.experimental.dimentional-threading", dimThreading); 
     }
 
     public static boolean logPlayerLoginLoc = false;
@@ -182,5 +186,6 @@ public class TitaniumConfig {
     public static double replace1 = ((double)biggestInt)-112.0D; // replacement for 2.9999872E7D
     public static double replace2 = WborderSize/2; // replacement for 3.0E7D
     public static int replace3 = biggestInt + 16; // replacement for 30000000
-
+    
+    public static boolean DEBUG = true; // Used for DIM-threading debugging
 }
diff --git a/src/main/java/me/titaniumtown/threading/ThreadPool.java b/src/main/java/me/titaniumtown/threading/ThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba0e02a4cb5db227741c6ad5a4697587d3863f9b
--- /dev/null
+++ b/src/main/java/me/titaniumtown/threading/ThreadPool.java
@@ -0,0 +1,70 @@
+package me.titaniumtown.threading;
+
+import java.util.Iterator;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+public class ThreadPool {
+
+    private ThreadPoolExecutor executor;
+    private final int threadCount;
+
+    private final AtomicInteger activeCount = new AtomicInteger();
+
+    public ThreadPool(int threadCount) {
+        this.threadCount = threadCount;
+        this.restart();
+    }
+
+    public int getThreadCount() {
+        return this.threadCount;
+    }
+
+    public ThreadPoolExecutor getExecutor() {
+        return this.executor;
+    }
+
+    public void run(Runnable action) {
+        this.activeCount.getAndIncrement();
+
+        this.executor.execute(() -> {
+            action.run();
+            activeCount.getAndDecrement();
+        });
+    }
+
+    public <T> void iterate(Iterable<T> iterable, Consumer<T> action) {
+        iterable.forEach(t -> this.run(() -> action.accept(t)));
+    }
+
+    public <T> void iterate(Iterator<T> iterator, Consumer<T> action) {
+        iterator.forEachRemaining(t -> this.run(() -> action.accept(t)));
+    }
+
+    public void awaitFreeThread() {
+        while(this.activeCount.get() >= this.getThreadCount()) {
+            try {Thread.sleep(5);}
+            catch(InterruptedException ignored) {}
+        }
+    }
+
+    public void awaitCompletion() {
+        while(this.activeCount.get() != 0) {
+            try {Thread.sleep(5);}
+            catch(InterruptedException ignored) {}
+        }
+    }
+
+    public void restart() {
+        if(this.executor == null || this.executor.isShutdown()) {
+            this.executor = (ThreadPoolExecutor)Executors.newFixedThreadPool(this.threadCount);
+        }
+    }
+
+    public void shutdown() {
+        this.executor.shutdown();
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 83e3dcbbe36ce1f947f387ec55067e51a1b7384a..8f9ccb3cf09feecfaa1d01f7e1641d98891b4f46 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -27,14 +27,28 @@ import it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
 // Tuinity end
+import me.titaniumtown.dimthread.thread.IMutableMainThread;
 
-public class ChunkProviderServer extends IChunkProvider {
+// Titanium start - DIM-threading work
+public class ChunkProviderServer extends IChunkProvider implements IMutableMainThread {
+    private Thread serverThread;
+
+	@Override
+	public Thread getMainThread() {
+		return this.serverThread;
+	}
+
+	@Override
+	public void setMainThread(Thread thread) {
+		this.serverThread = thread;
+	}
+    // Titanium end
 
     private static final List<ChunkStatus> b = ChunkStatus.a(); static final List<ChunkStatus> getPossibleChunkStatuses() { return ChunkProviderServer.b; } // Paper - OBFHELPER
     private final ChunkMapDistance chunkMapDistance;
     public final ChunkGenerator chunkGenerator;
     private final WorldServer world;
-    public final Thread serverThread; // Paper - private -> public
+    // public final Thread serverThread; // Paper - private -> public // Titanium
     private final LightEngineThreaded lightEngine;
     public final ChunkProviderServer.a serverThreadQueue; // Paper private -> public
     public final PlayerChunkMap playerChunkMap;
@@ -143,7 +157,7 @@ public class ChunkProviderServer extends IChunkProvider {
     long chunkFutureAwaitCounter; // Tuinity - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -153,7 +167,7 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -163,7 +177,7 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -173,7 +187,7 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<PlayerChunk, CompletableFuture<Either<Chunk, PlayerChunk.Failure>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
@@ -272,7 +286,7 @@ public class ChunkProviderServer extends IChunkProvider {
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                   java.util.function.Function<PlayerChunk, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function,
                                   java.util.function.Consumer<IChunkAccess> consumer) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(chunkX, chunkZ);
@@ -466,7 +480,7 @@ public class ChunkProviderServer extends IChunkProvider {
         /*
         long k = ChunkCoordIntPair.pair(x, z);
 
-        if (Thread.currentThread() == this.serverThread) {
+        if (me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -509,7 +523,7 @@ public class ChunkProviderServer extends IChunkProvider {
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = new CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>();
             this.serverThreadQueue.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -667,7 +681,7 @@ public class ChunkProviderServer extends IChunkProvider {
             return ifLoaded;
         }
         // AirplaneL end
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
@@ -738,7 +752,7 @@ public class ChunkProviderServer extends IChunkProvider {
     @Override
     public Chunk a(int i, int j) {
         // AirplaneL start
-//        if (Thread.currentThread() != this.serverThread) {
+//        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
 //            return null;
 //        } else {
             return this.getChunkAtIfLoadedMainThread(i, j); // Paper - optimise for loaded chunks
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 68471de8f7e8ee10ac1f85e919aee4db4c6ba008..b7a98b228f08f09868a5be1923fcb139eb7bb2b1 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -66,8 +66,20 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import io.papermc.paper.util.PaperJvmChecker; // Paper
 import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+// Titanium start - imports for DIM-threading
+import me.titaniumtown.dimthread.DimThread;
+import me.titaniumtown.threading.ThreadPool;
+// Titanium end
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
+    // Titanium start - variables needed for DIM-threading 
+    private ThreadPool pool = new ThreadPool(Runtime.getRuntime().availableProcessors());
+    // public abstract Iterable<WorldServer> getWorlds();
+    public Iterable<WorldServer> getWorlds() {
+        return this.worldServer.values();
+    }
+    private static boolean DEBUG = me.titaniumtown.TitaniumConfig.DEBUG;
+    // Titanium end - variables needed for DIM-threading 
 
     private static MinecraftServer SERVER; // Paper
     public static final Logger LOGGER = LogManager.getLogger();
@@ -1353,117 +1365,174 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     }
 
     protected void b(BooleanSupplier booleansupplier) {
-        // Tuinity - replace logic
-        MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
-        this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
-        MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
-        // Tuinity - replace logic
-        this.methodProfiler.enter("commandFunctions");
-        MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
-        this.getFunctionData().tick();
-        MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
-        // Tuinity - replace logic
-        this.methodProfiler.exitEnter("levels");
-        Iterator iterator = this.getWorlds().iterator();
+        if (!me.titaniumtown.TitaniumConfig.dimThreading) {
+            // Tuinity - replace logic
+            MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
+            this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
+            MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
+            // Tuinity - replace logic
+            this.methodProfiler.enter("commandFunctions");
+            MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
+            this.getFunctionData().tick();
+            MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
+            // Tuinity - replace logic
+            this.methodProfiler.exitEnter("levels");
+            Iterator iterator = this.getWorlds().iterator();
 
-        // CraftBukkit start
-        // Run tasks that are waiting on processing
-        MinecraftTimings.processQueueTimer.startTiming(); // Spigot
-        while (!processQueue.isEmpty()) {
-            processQueue.remove().run();
-        }
-        MinecraftTimings.processQueueTimer.stopTiming(); // Spigot
-        // Tuinity - replace logic
-        MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot // Paper
-        // Send time updates to everyone, it will get the right time from the world the player is in.
-        // Paper start - optimize time updates
-        for (final WorldServer world : this.getWorlds()) {
-            final boolean doDaylight = world.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE);
-            final long dayTime = world.getDayTime();
-            long worldTime = world.getTime();
-            final PacketPlayOutUpdateTime worldPacket = new PacketPlayOutUpdateTime(worldTime, dayTime, doDaylight);
-            for (EntityHuman entityhuman : world.getPlayers()) {
-                if (!(entityhuman instanceof EntityPlayer) || (ticks + entityhuman.getId()) % 20 != 0) {
-                    continue;
+            // CraftBukkit start
+            // Run tasks that are waiting on processing
+            MinecraftTimings.processQueueTimer.startTiming(); // Spigot
+            while (!processQueue.isEmpty()) {
+                processQueue.remove().run();
+            }
+            MinecraftTimings.processQueueTimer.stopTiming(); // Spigot
+            // Tuinity - replace logic
+            MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot // Paper
+            // Send time updates to everyone, it will get the right time from the world the player is in.
+            // Paper start - optimize time updates
+            for (final WorldServer world : this.getWorlds()) {
+                final boolean doDaylight = world.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE);
+                final long dayTime = world.getDayTime();
+                long worldTime = world.getTime();
+                final PacketPlayOutUpdateTime worldPacket = new PacketPlayOutUpdateTime(worldTime, dayTime, doDaylight);
+                for (EntityHuman entityhuman : world.getPlayers()) {
+                    if (!(entityhuman instanceof EntityPlayer) || (ticks + entityhuman.getId()) % 20 != 0) {
+                        continue;
+                    }
+                    EntityPlayer entityplayer = (EntityPlayer) entityhuman;
+                    long playerTime = entityplayer.getPlayerTime();
+                    PacketPlayOutUpdateTime packet = (playerTime == dayTime) ? worldPacket :
+                        new PacketPlayOutUpdateTime(worldTime, playerTime, doDaylight);
+                    entityplayer.playerConnection.sendPacket(packet); // Add support for per player time
                 }
-                EntityPlayer entityplayer = (EntityPlayer) entityhuman;
-                long playerTime = entityplayer.getPlayerTime();
-                PacketPlayOutUpdateTime packet = (playerTime == dayTime) ? worldPacket :
-                    new PacketPlayOutUpdateTime(worldTime, playerTime, doDaylight);
-                entityplayer.playerConnection.sendPacket(packet); // Add support for per player time
             }
-        }
-        // Paper end
-        MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
+            // Paper end
+            MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
 
-        while (iterator.hasNext()) {
-            WorldServer worldserver = (WorldServer) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent = net.pl3x.purpur.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
-            worldserver.hasRidableMoveEvent = net.pl3x.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+            while (iterator.hasNext()) {
+                WorldServer worldserver = (WorldServer) iterator.next();
+                worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                worldserver.hasEntityMoveEvent = net.pl3x.purpur.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+                worldserver.hasRidableMoveEvent = net.pl3x.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+
+                this.methodProfiler.a(() -> {
+                    return worldserver + " " + worldserver.getDimensionKey().a();
+                });
+                /* Drop global time updates
+                if (this.ticks % 20 == 0) {
+                    this.methodProfiler.enter("timeSync");
+                    this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.getDimensionKey());
+                    this.methodProfiler.exit();
+                }
+                // CraftBukkit end */
+                this.methodProfiler.enter("tick");
+
+                try {
+                    // Tuinity - replace logic
+                    worldserver.timings.doTick.startTiming(); // Spigot
+                    worldserver.doTick(booleansupplier);
+                    worldserver.getChunkProvider().playerChunkMap.dataRegionManager.recalculateRegions(); // Tuinity
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                    // Tuinity - replace logic
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
+                }
 
-            this.methodProfiler.a(() -> {
-                return worldserver + " " + worldserver.getDimensionKey().a();
-            });
-            /* Drop global time updates
-            if (this.ticks % 20 == 0) {
-                this.methodProfiler.enter("timeSync");
-                this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.getDimensionKey());
                 this.methodProfiler.exit();
+                this.methodProfiler.exit();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
             }
-            // CraftBukkit end */
+        } else {
+            // Titanium end - comment out single-threaded dim code
 
-            this.methodProfiler.enter("tick");
+            // Titanium start - Real DIM-threading work
+            // Tuinity - replace logic
+            // MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
+            this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
+            // MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
+            // Tuinity - replace logic
+            this.methodProfiler.enter("commandFunctions");
+            // MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
+            this.getFunctionData().tick();
+            // MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
+            // Tuinity - replace logic
+            this.methodProfiler.exitEnter("levels");
+            // Iterator iterator = this.getWorlds().iterator();
+
+            if(DEBUG)System.out.format("==================================================\n");
+
+            AtomicReference<CrashReport> crashReport = new AtomicReference<>();
+
+            this.pool.iterate(this.getWorlds().iterator(), worldserver -> {
+                DimThread.attach(Thread.currentThread(), worldserver);
+                // String dimensionName = worldserver.getDimension().getSkyProperties().getPath(); // TODO - FIX
+
+                // if(DEBUG)System.out.format("[%d] Started %s\n", this.ticks, dimensionName);
+
+                if (this.ticks % 20 == 0) {
+                    this.methodProfiler.enter("timeSync");
+                    this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.getDimensionKey());
+                    this.methodProfiler.exit();
+                }
 
-            try {
-                // Tuinity - replace logic
-                worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.doTick(booleansupplier);
-                worldserver.getChunkProvider().playerChunkMap.dataRegionManager.recalculateRegions(); // Tuinity
-                worldserver.timings.doTick.stopTiming(); // Spigot
-                // Tuinity - replace logic
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
                 try {
-                    crashreport = CrashReport.a(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
+                    DimThread.swapThreadsAndRun(() -> worldserver.doTick(booleansupplier), worldserver, worldserver.getChunkProvider());
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
                 }
-                // Spigot End
 
-                worldserver.a(crashreport);
-                throw new ReportedException(crashreport);
-            }
+                this.methodProfiler.exit();
+                this.methodProfiler.exit();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
 
-            this.methodProfiler.exit();
-            this.methodProfiler.exit();
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
-        }
+                // if(DEBUG)System.out.format("[%d] Finished %s\n", this.ticks, dimensionName);
+            });
+            if(DEBUG)System.out.format("Ticking completed!\n");
+            this.methodProfiler.exitEnter("connection");
+            // MinecraftTimings.connectionTimer.startTiming(); // Spigot
+            this.getServerConnection().c();
+            // MinecraftTimings.connectionTimer.stopTiming(); // Spigot
+            this.methodProfiler.exitEnter("players");
+            // MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
+            this.playerList.tick();
+            // MinecraftTimings.playerListTimer.stopTiming(); // Spigot // Paper
+            if (SharedConstants.d) {
+                GameTestHarnessTicker.a.b();
+            }
 
-        this.methodProfiler.exitEnter("connection");
-        MinecraftTimings.connectionTimer.startTiming(); // Spigot
-        this.getServerConnection().c();
-        MinecraftTimings.connectionTimer.stopTiming(); // Spigot
-        this.methodProfiler.exitEnter("players");
-        MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
-        this.playerList.tick();
-        MinecraftTimings.playerListTimer.stopTiming(); // Spigot // Paper
-        if (SharedConstants.d) {
-            GameTestHarnessTicker.a.b();
-        }
+            this.methodProfiler.exitEnter("server gui refresh");
 
-        this.methodProfiler.exitEnter("server gui refresh");
+            // MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
+            for (int i = 0; i < this.tickables.size(); ++i) {
+                ((Runnable) this.tickables.get(i)).run();
+            }
+            // MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper
 
-        MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
-        for (int i = 0; i < this.tickables.size(); ++i) {
-            ((Runnable) this.tickables.get(i)).run();
+            this.methodProfiler.exit();
+            // Titanium end - Real DIM-threading work
         }
-        MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper
-
-        this.methodProfiler.exit();
     }
 
     public boolean getAllowNether() {
@@ -1495,9 +1564,11 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         return this.worldServer.keySet();
     }
 
-    public Iterable<WorldServer> getWorlds() {
-        return this.worldServer.values();
-    }
+    // Titanium start - Move up
+    // public Iterable<WorldServer> getWorlds() {
+    //     return this.worldServer.values();
+    // }
+    // Titanium end - Move up
 
     public String getVersion() {
         return SharedConstants.getGameVersion().getName();
@@ -1898,7 +1969,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             this.saveData.a(a(this.resourcePackRepository));
             datapackresources.i();
             new ServerResourcesReloadedEvent(cause).callEvent(); // Paper
-            if (Thread.currentThread() != this.serverThread) return; // Paper
+            if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) return; // Paper
             //this.getPlayerList().savePlayers(); // Paper - we don't need to do this
             this.getPlayerList().reload();
             this.customFunctionData.a(this.dataPackResources.a());
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3e8d62a55b2dbd3a488e578f177fda599312c0c9..542f87cc1cfd66310c718d28fe4916552d71fd4c 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -32,8 +32,22 @@ import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
+import me.titaniumtown.dimthread.thread.IMutableMainThread; // Titanium - import for DIM-threading
 
-public abstract class World implements GeneratorAccess, AutoCloseable {
+public abstract class World implements GeneratorAccess, AutoCloseable, IMutableMainThread { // Titanium 
+    // Titanium start - DIM-threading work
+    private Thread thread;
+
+    @Override
+	public Thread getMainThread() {
+		return this.thread;
+	}
+    
+    @Override
+	public void setMainThread(Thread thread) {
+		this.thread = thread;
+	}
+    // Titanium end - DIM-threading work
 
     protected static final Logger LOGGER = LogManager.getLogger();
     public static final Codec<ResourceKey<World>> f = MinecraftKey.a.xmap(ResourceKey.b(IRegistry.L), ResourceKey::a);
@@ -1112,7 +1126,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && !me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             return null;
         } else {
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 0e2bbf292be2bd20b01ec6e630ea3d8a8e8d3cc8..6322f50b97f4318556a222ffca1fcb97f6d4d320 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -241,7 +241,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
     public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, int toX, int toZ, // Yatopia
                                              java.util.function.Consumer<List<IChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.getChunkProvider().serverThreadQueue.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -634,7 +634,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || !me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 51e9c54cddf4b28ba3d3d892322c487774bdab70..d4673792aba012a928a038376e7da243acf559e7 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -5,12 +5,12 @@ import net.minecraft.server.MinecraftServer;
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false; // Titanium - async world ticking
     public static boolean shuttingDown = false; // Paper
 
     public static void catchOp(String reason)
     {
-        if ( ( enabled || com.tuinity.tuinity.util.TickThread.STRICT_THREAD_CHECKS ) && !org.bukkit.Bukkit.isPrimaryThread() ) // Tuinity
+        if ( ( enabled || com.tuinity.tuinity.util.TickThread.STRICT_THREAD_CHECKS ) && !org.bukkit.Bukkit.isPrimaryThread() && !me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) // Tuinity // Titanium - async world ticking
         {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed thread check for reason: Asynchronous " + reason, new Throwable()); // Tuinity - not all exceptions are printed
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 3c7b9a6d24e064f9c1ec5fb6d52f42627944d7fa..fe8636519166afbd98e033b1dee50eca8feb868d 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -34,6 +34,13 @@ public class TicksPerSecondCommand extends Command
             tpsAvg[i] = format( tps[i] );
         }
         sender.sendMessage(ChatColor.GOLD + "TPS from last 5s, 1m, 5m, 15m: " + org.apache.commons.lang.StringUtils.join(tpsAvg, ", ")); // Purpur
+        // Titanium start - add async ticking /tps messages
+        sender.sendMessage( ChatColor.GOLD + "Async world ticking: " + me.titaniumtown.TitaniumConfig.dimThreading);
+        if (me.titaniumtown.TitaniumConfig.dimThreading) {
+            sender.sendMessage( ChatColor.GOLD + "Threads being used for async world ticking " + me.titaniumtown.TitaniumConfig.dimThreadingThreads);
+            // sender.sendMessage( ChatColor.GOLD + "The worlds where ticking for " + net.minecraft.server.MinecraftServer.worldTick + "ms"); // TODO
+        }
+        // Titanium end
         if (args.length > 0 && args[0].equals("mem") && sender.hasPermission("bukkit.command.tpsmemory")) {
             sender.sendMessage(ChatColor.GOLD + "Current Memory Usage: " + ChatColor.GREEN + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024)) + "/" + (Runtime.getRuntime().totalMemory() / (1024 * 1024)) + " mb (Max: " + (Runtime.getRuntime().maxMemory() / (1024 * 1024)) + " mb)");
             if (!hasShownMemoryWarning) {
