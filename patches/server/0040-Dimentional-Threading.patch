From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Mon, 4 Jan 2021 21:06:13 -0500
Subject: [PATCH] Dimentional Threading


diff --git a/src/main/java/com/tuinity/tuinity/util/TickThread.java b/src/main/java/com/tuinity/tuinity/util/TickThread.java
index 08ed243259f052165c6f75aed1d1d65a14219715..c226432f1c058cd82877786fcab07829716b7bbe 100644
--- a/src/main/java/com/tuinity/tuinity/util/TickThread.java
+++ b/src/main/java/com/tuinity/tuinity/util/TickThread.java
@@ -22,7 +22,7 @@ public final class TickThread extends Thread {
 
 
     public static void ensureTickThread(final String reason) {
-        if (!Bukkit.isPrimaryThread()) {
+        if (!Bukkit.isPrimaryThread()) {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
diff --git a/src/main/java/me/titaniumtown/DimThread/DimThread.java b/src/main/java/me/titaniumtown/DimThread/DimThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff119aab59e914c3c760b752dc5b10db9a8eee00
--- /dev/null
+++ b/src/main/java/me/titaniumtown/DimThread/DimThread.java
@@ -0,0 +1,53 @@
+package me.titaniumtown.dimthread;
+
+import me.titaniumtown.dimthread.thread.IMutableMainThread;
+import me.titaniumtown.dimthread.util.ServerManager;
+import me.titaniumtown.threading.ThreadPool;
+import net.minecraft.server.WorldServer;
+import net.minecraft.server.MinecraftServer;
+
+public class DimThread {
+    public static final String MOD_ID = "dimthread";
+    public static final ServerManager MANAGER = new ServerManager();
+
+    public static ThreadPool getThreadPool(MinecraftServer server) {
+        return MANAGER.getThreadPool(server);
+    }
+
+    public static void swapThreadsAndRun(Runnable task, Object... threadedObjects) {
+        Thread currentThread = Thread.currentThread();
+        Thread[] oldThreads = new Thread[threadedObjects.length];
+
+        for(int i = 0; i < oldThreads.length; i++) {
+            oldThreads[i] = ((IMutableMainThread)threadedObjects[i]).getMainThread();
+            ((IMutableMainThread)threadedObjects[i]).setMainThread(currentThread);
+        }
+
+        task.run();
+
+        for(int i = 0; i < oldThreads.length; i++) {
+            ((IMutableMainThread)threadedObjects[i]).setMainThread(oldThreads[i]);
+        }
+    }
+
+    /**
+        * Makes it easy to understand what is happening in crash reports and helps identify dimthread workers.
+        * */
+    public static void attach(Thread thread, String name) {
+        thread.setName(MOD_ID + "_" + name);
+    }
+
+    public static void attach(Thread thread, WorldServer world) {
+        // attach(thread, world.getRegistryKey().getValue().getPath());
+        thread.setName(MOD_ID);
+    }
+
+    /**
+        * Checks if the given thread is a dimthread worker by checking the name. Probably quite fragile...
+        * */
+    // `Thread.currentThread() == this.serverThread` is the same as `me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())`
+    // `Thread.currentThread() != this.serverThread` is the same as `!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())`
+    public static boolean owns(Thread thread) {
+        return me.titaniumtown.threading.TitaniumThreadHandler.isTitaniumThread(thread);//thread.getName().startsWith(MOD_ID);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/DimThread/thread/IMutableMainThread.java b/src/main/java/me/titaniumtown/DimThread/thread/IMutableMainThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..475597240a1c091e6a1ff6be0682ff996ea91da1
--- /dev/null
+++ b/src/main/java/me/titaniumtown/DimThread/thread/IMutableMainThread.java
@@ -0,0 +1,6 @@
+package me.titaniumtown.dimthread.thread;
+
+public interface IMutableMainThread {
+	Thread getMainThread();
+	void setMainThread(Thread thread);
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/DimThread/util/ServerManager.java b/src/main/java/me/titaniumtown/DimThread/util/ServerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..7871ea9f536b4ab907ff64493905aa7467706f6f
--- /dev/null
+++ b/src/main/java/me/titaniumtown/DimThread/util/ServerManager.java
@@ -0,0 +1,39 @@
+package me.titaniumtown.dimthread.util;
+
+import net.minecraft.server.MinecraftServer;
+import me.titaniumtown.threading.ThreadPool;
+
+import java.util.Collections;
+import java.util.ConcurrentModificationException;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+public class ServerManager {
+
+	private final Map<MinecraftServer, Boolean> actives = Collections.synchronizedMap(new WeakHashMap<>());
+	private final Map<MinecraftServer, ThreadPool> threadPools = Collections.synchronizedMap(new WeakHashMap<>());
+
+	public boolean isActive(MinecraftServer server) {
+		return me.titaniumtown.TitaniumConfig.dimThreading;
+	}
+
+	public void setActive(MinecraftServer server) {
+		this.actives.put(server, me.titaniumtown.TitaniumConfig.dimThreading);
+	}
+
+	public ThreadPool getThreadPool(MinecraftServer server) {
+		return this.threadPools.computeIfAbsent(server, s -> new ThreadPool(me.titaniumtown.TitaniumConfig.dimThreadingThreads));
+	}
+
+	public void setThreadCount(MinecraftServer server) {
+		ThreadPool current = this.threadPools.get(server);
+
+		// if(current.getActiveCount() != 0) {
+		// 	throw new ConcurrentModificationException("Setting the thread count in wrong phase");
+		// }
+
+		this.threadPools.put(server, new ThreadPool(me.titaniumtown.TitaniumConfig.dimThreadingThreads));
+		current.shutdown();
+	}
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/TitaniumConfig.java b/src/main/java/me/titaniumtown/TitaniumConfig.java
index 4737daae4b0acd65dbbc5e56134885c50ce36e64..e42dccedd0961ae9672f615e4e07f43b9925c9f7 100644
--- a/src/main/java/me/titaniumtown/TitaniumConfig.java
+++ b/src/main/java/me/titaniumtown/TitaniumConfig.java
@@ -156,10 +156,14 @@ public class TitaniumConfig {
     public static boolean allowSandDupe = false;
     public static boolean worldBorderChecks = true;
     public static boolean allowAllDupes = false;
+    public static int dimThreadingThreads = 4;
+    public static boolean dimThreading = false;
     private static void experimental() {
         allowSandDupe = getBoolean("settings.experimental.allow-sand-dupe", allowSandDupe);
         worldBorderChecks = getBoolean("settings.experimental.world-border-checks", worldBorderChecks);
         allowAllDupes = getBoolean("settings.experimental.allow-all-dupes", allowAllDupes);
+        dimThreadingThreads = getInt("settings.experimental.dimentional-threads", dimThreadingThreads);
+        dimThreading = getBoolean("settings.experimental.dimentional-threading", dimThreading); 
     }
 
     public static boolean logPlayerLoginLoc = false;
@@ -182,5 +186,6 @@ public class TitaniumConfig {
     public static double replace1 = ((double)biggestInt)-112.0D; // replacement for 2.9999872E7D
     public static double replace2 = WborderSize/2; // replacement for 3.0E7D
     public static int replace3 = biggestInt + 16; // replacement for 30000000
-
+    
+    public static boolean DEBUG = true; // Used for DIM-threading debugging
 }
diff --git a/src/main/java/me/titaniumtown/threading/ThreadPool.java b/src/main/java/me/titaniumtown/threading/ThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba0e02a4cb5db227741c6ad5a4697587d3863f9b
--- /dev/null
+++ b/src/main/java/me/titaniumtown/threading/ThreadPool.java
@@ -0,0 +1,70 @@
+package me.titaniumtown.threading;
+
+import java.util.Iterator;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+public class ThreadPool {
+
+    private ThreadPoolExecutor executor;
+    private final int threadCount;
+
+    private final AtomicInteger activeCount = new AtomicInteger();
+
+    public ThreadPool(int threadCount) {
+        this.threadCount = threadCount;
+        this.restart();
+    }
+
+    public int getThreadCount() {
+        return this.threadCount;
+    }
+
+    public ThreadPoolExecutor getExecutor() {
+        return this.executor;
+    }
+
+    public void run(Runnable action) {
+        this.activeCount.getAndIncrement();
+
+        this.executor.execute(() -> {
+            action.run();
+            activeCount.getAndDecrement();
+        });
+    }
+
+    public <T> void iterate(Iterable<T> iterable, Consumer<T> action) {
+        iterable.forEach(t -> this.run(() -> action.accept(t)));
+    }
+
+    public <T> void iterate(Iterator<T> iterator, Consumer<T> action) {
+        iterator.forEachRemaining(t -> this.run(() -> action.accept(t)));
+    }
+
+    public void awaitFreeThread() {
+        while(this.activeCount.get() >= this.getThreadCount()) {
+            try {Thread.sleep(5);}
+            catch(InterruptedException ignored) {}
+        }
+    }
+
+    public void awaitCompletion() {
+        while(this.activeCount.get() != 0) {
+            try {Thread.sleep(5);}
+            catch(InterruptedException ignored) {}
+        }
+    }
+
+    public void restart() {
+        if(this.executor == null || this.executor.isShutdown()) {
+            this.executor = (ThreadPoolExecutor)Executors.newFixedThreadPool(this.threadCount);
+        }
+    }
+
+    public void shutdown() {
+        this.executor.shutdown();
+    }
+
+}
diff --git a/src/main/java/me/titaniumtown/threading/TitaniumThreadHandler.java b/src/main/java/me/titaniumtown/threading/TitaniumThreadHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c9b5aa7283c880bc95b4c3a43dd3da45435b438
--- /dev/null
+++ b/src/main/java/me/titaniumtown/threading/TitaniumThreadHandler.java
@@ -0,0 +1,17 @@
+package me.titaniumtown.threading;
+import org.bukkit.craftbukkit.util.WeakCollection;
+
+public class TitaniumThreadHandler {
+
+    private static final WeakCollection<Thread> weakMainThreads = new WeakCollection<Thread>();
+
+    public static void registerThread(Thread thread) {
+        weakMainThreads.add(thread);
+    }
+
+    public static boolean isTitaniumThread(Thread thread) {
+        return weakMainThreads.contains(thread);
+    }
+
+}
+
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 83e3dcbbe36ce1f947f387ec55067e51a1b7384a..8f9ccb3cf09feecfaa1d01f7e1641d98891b4f46 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -27,14 +27,28 @@ import it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
 // Tuinity end
+import me.titaniumtown.dimthread.thread.IMutableMainThread;
 
-public class ChunkProviderServer extends IChunkProvider {
+// Titanium start - DIM-threading work
+public class ChunkProviderServer extends IChunkProvider implements IMutableMainThread {
+    private Thread serverThread;
+
+	@Override
+	public Thread getMainThread() {
+		return this.serverThread;
+	}
+
+	@Override
+	public void setMainThread(Thread thread) {
+		this.serverThread = thread;
+	}
+    // Titanium end
 
     private static final List<ChunkStatus> b = ChunkStatus.a(); static final List<ChunkStatus> getPossibleChunkStatuses() { return ChunkProviderServer.b; } // Paper - OBFHELPER
     private final ChunkMapDistance chunkMapDistance;
     public final ChunkGenerator chunkGenerator;
     private final WorldServer world;
-    public final Thread serverThread; // Paper - private -> public
+    // public final Thread serverThread; // Paper - private -> public // Titanium
     private final LightEngineThreaded lightEngine;
     public final ChunkProviderServer.a serverThreadQueue; // Paper private -> public
     public final PlayerChunkMap playerChunkMap;
@@ -143,7 +157,7 @@ public class ChunkProviderServer extends IChunkProvider {
     long chunkFutureAwaitCounter; // Tuinity - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -153,7 +167,7 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -163,7 +177,7 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -173,7 +187,7 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<PlayerChunk, CompletableFuture<Either<Chunk, PlayerChunk.Failure>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
@@ -272,7 +286,7 @@ public class ChunkProviderServer extends IChunkProvider {
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                   java.util.function.Function<PlayerChunk, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function,
                                   java.util.function.Consumer<IChunkAccess> consumer) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(chunkX, chunkZ);
@@ -466,7 +480,7 @@ public class ChunkProviderServer extends IChunkProvider {
         /*
         long k = ChunkCoordIntPair.pair(x, z);
 
-        if (Thread.currentThread() == this.serverThread) {
+        if (me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -509,7 +523,7 @@ public class ChunkProviderServer extends IChunkProvider {
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = new CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>();
             this.serverThreadQueue.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -667,7 +681,7 @@ public class ChunkProviderServer extends IChunkProvider {
             return ifLoaded;
         }
         // AirplaneL end
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
@@ -738,7 +752,7 @@ public class ChunkProviderServer extends IChunkProvider {
     @Override
     public Chunk a(int i, int j) {
         // AirplaneL start
-//        if (Thread.currentThread() != this.serverThread) {
+//        if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
 //            return null;
 //        } else {
             return this.getChunkAtIfLoadedMainThread(i, j); // Paper - optimise for loaded chunks
diff --git a/src/main/java/net/minecraft/server/IAsyncTaskHandler.java b/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
index 27db247aa40e0516302c74b9bf00c631a8607af5..48794a6edc03bd79f00c5348976cbd083eef8f17 100644
--- a/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
+++ b/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
@@ -6,6 +6,8 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
+
+import me.titaniumtown.threading.TitaniumThreadHandler;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -25,7 +27,7 @@ public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R
     protected abstract boolean canExecute(R r0);
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.getThread();
+        return TitaniumThreadHandler.isTitaniumThread(Thread.currentThread());
     }
 
     protected abstract Thread getThread();
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index e79e773f2219f9a9ae076fcbc8108b792201b11a..b965b5bf593941e41bb09cb473f9ff38ed9ddb22 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -5,6 +5,7 @@ import com.destroystokyo.paper.profile.CraftPlayerProfile;
 import com.destroystokyo.paper.profile.PlayerProfile;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import me.titaniumtown.threading.TitaniumThreadHandler;
 import org.apache.commons.lang.exception.ExceptionUtils;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
@@ -362,7 +363,7 @@ public final class MCUtil {
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && !TitaniumThreadHandler.isTitaniumThread(Thread.currentThread())) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -387,7 +388,7 @@ public final class MCUtil {
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && !TitaniumThreadHandler.isTitaniumThread(Thread.currentThread())) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 68471de8f7e8ee10ac1f85e919aee4db4c6ba008..083d5d3f7cf3e4f92ddb04fa2d1b0002a2168be9 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -51,23 +51,17 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
-import javax.imageio.ImageIO;
-import org.apache.commons.lang3.Validate;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-// CraftBukkit start
-import com.google.common.collect.ImmutableSet;
-// import jline.console.ConsoleReader; // Paper
-import joptsimple.OptionSet;
-import org.bukkit.event.server.ServerLoadEvent;
-// CraftBukkit end
-import co.aikar.timings.MinecraftTimings; // Paper
-import io.papermc.paper.util.PaperJvmChecker; // Paper
-import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
-import org.spigotmc.SlackActivityAccountant; // Spigot
+// Titanium end
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
+    // Titanium start - variables needed for DIM-threading 
+    private ThreadPool pool = new ThreadPool(Runtime.getRuntime().availableProcessors());
+    // public abstract Iterable<WorldServer> getWorlds();
+    public Iterable<WorldServer> getWorlds() {
+        return this.worldServer.values();
+    }
+    private static boolean DEBUG = me.titaniumtown.TitaniumConfig.DEBUG;
+    // Titanium end - variables needed for DIM-threading 
 
     private static MinecraftServer SERVER; // Paper
     public static final Logger LOGGER = LogManager.getLogger();
@@ -178,6 +172,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         thread.setUncaughtExceptionHandler((thread1, throwable) -> {
             MinecraftServer.LOGGER.error(throwable);
         });
+        TitaniumThreadHandler.registerThread(thread);
         S s0 = function.apply(thread); // CraftBukkit - decompile error
 
         atomicreference.set(s0);
@@ -1388,82 +1383,132 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
                 }
                 EntityPlayer entityplayer = (EntityPlayer) entityhuman;
                 long playerTime = entityplayer.getPlayerTime();
-                PacketPlayOutUpdateTime packet = (playerTime == dayTime) ? worldPacket :
-                    new PacketPlayOutUpdateTime(worldTime, playerTime, doDaylight);
+                PacketPlayOutUpdateTime packet = (playerTime == dayTime) ? worldPacket : new PacketPlayOutUpdateTime(worldTime, playerTime, doDaylight);
                 entityplayer.playerConnection.sendPacket(packet); // Add support for per player time
             }
         }
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
+        if(!me.titaniumtown.TitaniumConfig.dimThreading){
+            while (iterator.hasNext()) {
+                WorldServer worldserver = (WorldServer) iterator.next();
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                worldserver.hasEntityMoveEvent = net.pl3x.purpur.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+                worldserver.hasRidableMoveEvent = net.pl3x.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+
+                this.methodProfiler.a(() -> {
+                    return worldserver + " " + worldserver.getDimensionKey().a();
+                });
+                    /* Drop global time updates
+                    if (this.ticks % 20 == 0) {
+                        this.methodProfiler.enter("timeSync");
+                        this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.getDimensionKey());
+                        this.methodProfiler.exit();
+                    }
+                    // CraftBukkit end */
+                this.methodProfiler.enter("tick");
 
-        while (iterator.hasNext()) {
-            WorldServer worldserver = (WorldServer) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent = net.pl3x.purpur.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
-            worldserver.hasRidableMoveEvent = net.pl3x.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+                try {
+                    // Tuinity - replace logic
+                    worldserver.timings.doTick.startTiming(); // Spigot
+                    worldserver.doTick(booleansupplier);
+                    worldserver.getChunkProvider().playerChunkMap.dataRegionManager.recalculateRegions(); // Tuinity
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                    // Tuinity - replace logic
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) { throw (ThreadDeath) throwable; } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
 
-            this.methodProfiler.a(() -> {
-                return worldserver + " " + worldserver.getDimensionKey().a();
-            });
-            /* Drop global time updates
-            if (this.ticks % 20 == 0) {
-                this.methodProfiler.enter("timeSync");
-                this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.getDimensionKey());
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
+                }
+
+                this.methodProfiler.exit();
                 this.methodProfiler.exit();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
             }
-            // CraftBukkit end */
 
-            this.methodProfiler.enter("tick");
+            // Titanium start - Real DIM-threading work
+            // Tuinity - replace logic
+            // MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
+            this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
+            // MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
+            // Tuinity - replace logic
+            this.methodProfiler.enter("commandFunctions");
+            // MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
+            this.getFunctionData().tick();
+            // MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
+            // Tuinity - replace logic
+            this.methodProfiler.exitEnter("levels");
+            // Iterator iterator = this.getWorlds().iterator();
+
+            if (DEBUG)
+                System.out.format("==================================================\n");
+
+        }else{
+            this.pool.iterate(this.getWorlds().iterator(), worldserver -> {
+                DimThread.attach(Thread.currentThread(), worldserver);
+                TitaniumThreadHandler.registerThread(Thread.currentThread()); // Remove async catcher stacktrace
+
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
 
-            try {
-                // Tuinity - replace logic
-                worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.doTick(booleansupplier);
-                worldserver.getChunkProvider().playerChunkMap.dataRegionManager.recalculateRegions(); // Tuinity
-                worldserver.timings.doTick.stopTiming(); // Spigot
-                // Tuinity - replace logic
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
                 try {
-                    crashreport = CrashReport.a(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
+                    DimThread.swapThreadsAndRun(() -> worldserver.doTick(booleansupplier), worldserver, worldserver.getChunkProvider());
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) { throw (ThreadDeath) throwable; } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
                 }
-                // Spigot End
-
-                worldserver.a(crashreport);
-                throw new ReportedException(crashreport);
-            }
 
-            this.methodProfiler.exit();
-            this.methodProfiler.exit();
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
-        }
+                this.methodProfiler.exit();
+                this.methodProfiler.exit();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
 
-        this.methodProfiler.exitEnter("connection");
-        MinecraftTimings.connectionTimer.startTiming(); // Spigot
-        this.getServerConnection().c();
-        MinecraftTimings.connectionTimer.stopTiming(); // Spigot
-        this.methodProfiler.exitEnter("players");
-        MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
-        this.playerList.tick();
-        MinecraftTimings.playerListTimer.stopTiming(); // Spigot // Paper
-        if (SharedConstants.d) {
-            GameTestHarnessTicker.a.b();
-        }
+                // if(DEBUG)System.out.format("[%d] Finished %s\n", this.ticks, dimensionName);
+            });
+            pool.awaitCompletion();
+        }
+
+            if(DEBUG)System.out.format("Ticking completed!\n");
+            this.methodProfiler.exitEnter("connection");
+            // MinecraftTimings.connectionTimer.startTiming(); // Spigot
+            this.getServerConnection().c();
+            // MinecraftTimings.connectionTimer.stopTiming(); // Spigot
+            this.methodProfiler.exitEnter("players");
+            // MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
+            this.playerList.tick();
+            // MinecraftTimings.playerListTimer.stopTiming(); // Spigot // Paper
+            if (SharedConstants.d) {
+                GameTestHarnessTicker.a.b();
+            }
 
-        this.methodProfiler.exitEnter("server gui refresh");
+            this.methodProfiler.exitEnter("server gui refresh");
 
-        MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
-        for (int i = 0; i < this.tickables.size(); ++i) {
-            ((Runnable) this.tickables.get(i)).run();
-        }
-        MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper
+            // MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
+            for (int i = 0; i < this.tickables.size(); ++i) {
+                ((Runnable) this.tickables.get(i)).run();
+            }
+            // MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper
 
-        this.methodProfiler.exit();
+            this.methodProfiler.exit();
+            // Titanium end - Real DIM-threading work
     }
 
     public boolean getAllowNether() {
@@ -1495,9 +1540,11 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         return this.worldServer.keySet();
     }
 
-    public Iterable<WorldServer> getWorlds() {
-        return this.worldServer.values();
-    }
+    // Titanium start - Move up
+    // public Iterable<WorldServer> getWorlds() {
+    //     return this.worldServer.values();
+    // }
+    // Titanium end - Move up
 
     public String getVersion() {
         return SharedConstants.getGameVersion().getName();
@@ -1898,7 +1945,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             this.saveData.a(a(this.resourcePackRepository));
             datapackresources.i();
             new ServerResourcesReloadedEvent(cause).callEvent(); // Paper
-            if (Thread.currentThread() != this.serverThread) return; // Paper
+            if (!me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) return; // Paper
             //this.getPlayerList().savePlayers(); // Paper - we don't need to do this
             this.getPlayerList().reload();
             this.customFunctionData.a(this.dataPackResources.a());
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3e8d62a55b2dbd3a488e578f177fda599312c0c9..5acc247baa503387dcb5776f107a18af08e73cc6 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -32,8 +32,22 @@ import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
+import me.titaniumtown.dimthread.thread.IMutableMainThread; // Titanium - import for DIM-threading
 
-public abstract class World implements GeneratorAccess, AutoCloseable {
+public abstract class World implements GeneratorAccess, AutoCloseable, IMutableMainThread { // Titanium 
+    // Titanium start - DIM-threading work
+    private Thread thread;
+
+    @Override
+	public Thread getMainThread() {
+		return this.thread;
+	}
+    
+    @Override
+	public void setMainThread(Thread thread) {
+		this.thread = thread;
+	}
+    // Titanium end - DIM-threading work
 
     protected static final Logger LOGGER = LogManager.getLogger();
     public static final Codec<ResourceKey<World>> f = MinecraftKey.a.xmap(ResourceKey.b(IRegistry.L), ResourceKey::a);
@@ -45,7 +59,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
     protected final List<TileEntity> tileEntityListPending = Lists.newArrayList();
     protected final java.util.Set<TileEntity> tileEntityListUnload = com.google.common.collect.Sets.newHashSet();
-    public final Thread serverThread;
+    // public final Thread serverThread;
     private final boolean debugWorld;
     private int d;
     protected int n = (new Random()).nextInt();
@@ -233,7 +247,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
             this.worldBorder = new WorldBorder();
         }
 
-        this.serverThread = Thread.currentThread();
+        // this.serverThread = Thread.currentThread();
         this.biomeManager = new BiomeManager(this, i, dimensionmanager.getGenLayerZoomer());
         this.debugWorld = flag1;
         // CraftBukkit start
@@ -1112,7 +1126,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && !me.titaniumtown.dimthread.DimThread.owns(Thread.currentThread())) {
             return null;
         } else {
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 0e2bbf292be2bd20b01ec6e630ea3d8a8e8d3cc8..0d102de4964db7b26fc449c6c0651829d40cf64b 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -241,7 +241,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
     public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, int toX, int toZ, // Yatopia
                                              java.util.function.Consumer<List<IChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!me.titaniumtown.threading.TitaniumThreadHandler.isTitaniumThread(Thread.currentThread())) {
             this.getChunkProvider().serverThreadQueue.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -634,7 +634,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || !me.titaniumtown.threading.TitaniumThreadHandler.isTitaniumThread(Thread.currentThread())) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 5b4046ca3b311c2aeaca31bc0af6547cf6d064f7..b62ac70127950616b42b7ea3e54162fe25f78667 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -47,6 +47,7 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.imageio.ImageIO;
 //import jline.console.ConsoleReader; // Paper
+import me.titaniumtown.threading.TitaniumThreadHandler;
 import net.minecraft.server.Advancement;
 import net.minecraft.server.ArgumentEntity;
 import net.minecraft.server.BiomeManager;
@@ -73,7 +74,6 @@ import net.minecraft.server.GameRules;
 import net.minecraft.server.GeneratorSettings;
 import net.minecraft.server.IRecipe;
 import net.minecraft.server.IRegistry;
-import net.minecraft.server.IRegistryCustom;
 import net.minecraft.server.Item;
 import net.minecraft.server.ItemWorldMap;
 import net.minecraft.server.Items;
@@ -1868,7 +1868,7 @@ public final class CraftServer implements Server {
     public boolean isPrimaryThread() {
         // Tuinity start
         final Thread currThread = Thread.currentThread();
-        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return TitaniumThreadHandler.isTitaniumThread(Thread.currentThread()) || currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
         // Tuinity End
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 8904b39db2203118fe3589133cb7e64334c20f33..d4aa0bf9fdbdbf0d3bc7b21be4abaff16df6f980 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -469,7 +469,7 @@ public class CraftWorld implements World {
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getMinecraftWorld().serverThread) {
+        if (!me.titaniumtown.threading.TitaniumThreadHandler.isTitaniumThread(Thread.currentThread())) {
             synchronized (world.getChunkProvider().playerChunkMap.visibleChunks) {
                 Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
                 return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 51e9c54cddf4b28ba3d3d892322c487774bdab70..e8276370f8d61dd2c1468e6514e55b1a178e1f25 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -5,12 +5,12 @@ import net.minecraft.server.MinecraftServer;
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false; // Titanium - async world ticking
     public static boolean shuttingDown = false; // Paper
 
     public static void catchOp(String reason)
     {
-        if ( ( enabled || com.tuinity.tuinity.util.TickThread.STRICT_THREAD_CHECKS ) && !org.bukkit.Bukkit.isPrimaryThread() ) // Tuinity
+        if ( ( enabled || com.tuinity.tuinity.util.TickThread.STRICT_THREAD_CHECKS ) && !org.bukkit.Bukkit.isPrimaryThread()) // Tuinity
         {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed thread check for reason: Asynchronous " + reason, new Throwable()); // Tuinity - not all exceptions are printed
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 3c7b9a6d24e064f9c1ec5fb6d52f42627944d7fa..fe8636519166afbd98e033b1dee50eca8feb868d 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -34,6 +34,13 @@ public class TicksPerSecondCommand extends Command
             tpsAvg[i] = format( tps[i] );
         }
         sender.sendMessage(ChatColor.GOLD + "TPS from last 5s, 1m, 5m, 15m: " + org.apache.commons.lang.StringUtils.join(tpsAvg, ", ")); // Purpur
+        // Titanium start - add async ticking /tps messages
+        sender.sendMessage( ChatColor.GOLD + "Async world ticking: " + me.titaniumtown.TitaniumConfig.dimThreading);
+        if (me.titaniumtown.TitaniumConfig.dimThreading) {
+            sender.sendMessage( ChatColor.GOLD + "Threads being used for async world ticking " + me.titaniumtown.TitaniumConfig.dimThreadingThreads);
+            // sender.sendMessage( ChatColor.GOLD + "The worlds where ticking for " + net.minecraft.server.MinecraftServer.worldTick + "ms"); // TODO
+        }
+        // Titanium end
         if (args.length > 0 && args[0].equals("mem") && sender.hasPermission("bukkit.command.tpsmemory")) {
             sender.sendMessage(ChatColor.GOLD + "Current Memory Usage: " + ChatColor.GREEN + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024)) + "/" + (Runtime.getRuntime().totalMemory() / (1024 * 1024)) + " mb (Max: " + (Runtime.getRuntime().maxMemory() / (1024 * 1024)) + " mb)");
             if (!hasShownMemoryWarning) {
